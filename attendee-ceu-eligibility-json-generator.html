<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV → Sessions (Slim) — first Description column</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;background:#f6f7fb;margin:0}
    .wrap{max-width:960px;margin:24px auto;padding:0 16px}
    .card{background:#fff;border-radius:12px;box-shadow:0 2px 10px rgba(0,0,0,.08);padding:20px}
    h1{font-size:20px;margin:0 0 12px}
    label{font-weight:600;font-size:13px}
    input[type="file"],input[type="text"]{padding:8px;border:1px solid #ddd;border-radius:8px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .btn{padding:9px 12px;border-radius:8px;border:1px solid #ddd;cursor:pointer}
    .btn.primary{background:#1f6feb;color:#fff;border-color:#1f6feb}
    .tog{display:flex;align-items:center;gap:6px;font-size:12px;color:#555}
    textarea{width:100%;height:440px;margin-top:10px;font-family:monospace;white-space:pre;border:1px solid #ddd;border-radius:8px;padding:10px}
    .indicator{font-size:12px;color:green;opacity:0;transition:opacity .15s}
    .indicator.show{opacity:1}
    .errors{white-space:pre-wrap;color:#b91c1c;font-weight:600}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>CSV → Sessions (Slim)</h1>
    <div class="row">
      <div>
        <label>Session CSV</label><br>
        <input id="sessionFile" type="file" accept=".csv">
      </div>
      <div>
        <label>Speaker CSV</label><br>
        <input id="speakerFile" type="file" accept=".csv">
      </div>
      <div>
        <label>Registration CSV</label><br>
        <input id="regFile" type="file" accept=".csv">
      </div>
      <div>
        <label>Timezone offset</label><br>
        <input id="tzOffset" type="text" value="-06:00">
      </div>
<div class="tog">
  <input id="fastMode" type="checkbox" checked>
  <label for="fastMode">Fast mode (dev)</label>
</div>
    </div>

<div class="controls">
  <button id="processBtn" class="btn primary">Process</button>
  <button id="copyOutSpeakersBtn" class="btn">Copy Output for Speakers</button><span id="copyOutSpeakersInd" class="indicator">Copied</span>
  <button id="copyOutSpeakersNoEmailBtn" class="btn">Copy Output for Speakers (no emails)</button><span id="copyOutSpeakersNoEmailInd" class="indicator">Copied</span>
  <button id="copyOutCEUBtn" class="btn">Copy Output for CEU Eligibility</button><span id="copyOutCEUInd" class="indicator">Copied</span>
  <button id="copyErrBtn" class="btn">Copy Errors</button><span id="copyErrInd" class="indicator">Copied</span>
  <button id="publishCEUBtn" class="btn">Publish CEU JSON</button><span id="publishCEUInd" class="indicator">Published!</span>
<button id="publishSpeakersNoEmailBtn" class="btn">Publish Speakers (no emails)</button><span id="publishSpeakersNoEmailInd" class="indicator">Published!</span>
</div>


    <textarea id="out"></textarea>
    <div id="errs" class="errors"></div>
  </div>
</div>

<script>
/* ---------- CSV helpers (quoted commas + multiline safe) ---------- */
function parseCSVLine(line){
  const out=[];let cur='',inQ=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i];
    if(ch==='"'){ if(inQ && i+1<line.length && line[i+1]==='"'){cur+='"';i++;} else{inQ=!inQ;} }
    else if(ch===',' && !inQ){ out.push(cur); cur=''; }
    else cur+=ch;
  }
  out.push(cur); return out;
}
function splitIntoLogicalRows(text){
  const phys=String(text).split(/\r\n|\n/),rows=[];let buf='',q=0;
  for(const line of phys){
    if(buf===''){buf=line;q=(line.match(/"/g)||[]).length;}
    else{buf+='\n'+line;q+=(line.match(/"/g)||[]).length;}
    if(q%2===0){rows.push(buf);buf='';q=0;}
  }
  if(buf.trim()!=='')rows.push(buf);
  return rows.filter(r=>r.trim()!=='');
}
function cleanCell(v){
  if(v===undefined||v===null) return '';
  v=String(v).trim();
  if(v.startsWith('"') && v.endsWith('"') && v.length>=2) v=v.slice(1,-1).replace(/""/g,'"');
  return v;
}
function normalizeHeader(h){
  return String(h||'').replace(/^\uFEFF/, '').toLowerCase().replace(/\s+/g,' ').trim();
}

/* ---------- Date helpers (expects "MM/DD/YYYY hh:mm:ss AM/PM") ---------- */
function parseDateTimeString(s){
  const p=String(s||'').trim().split(' '); if(p.length<3)return null;
  const [mdy,hms,amp]=p; const dP=mdy.split('/'), tP=hms.split(':');
  if(dP.length!==3||tP.length!==3)return null;
  let [m,d,y]=dP.map(Number); let [H,Mi,S]=tP.map(Number);
  if([m,d,y,H,Mi,S].some(isNaN))return null;
  const ampu=(amp||'').toUpperCase();
  if(ampu==='PM'&&H<12)H+=12; if(ampu==='AM'&&H===12)H=0;
  return{y,m,d,H,Mi,S};
}
function monthName(m){return['January','February','March','April','May','June','July','August','September','October','November','December'][m-1];}
function formatDate(dt){return`${monthName(dt.m)} ${dt.d}, ${dt.y}`;}
function fmt12(h){let v=h%12;return v===0?12:v;}
function formatTimeOnly(dt){const mm=String(dt.Mi).padStart(2,'0');const per=dt.H<12?'AM':'PM';return`${fmt12(dt.H)}:${mm} ${per}`;}
function formatTimeRange(s,e){if(!s)return'';if(!e)return formatTimeOnly(s);return`${formatTimeOnly(s)} - ${formatTimeOnly(e)}`;}
function formatISO(dt){return`${dt.y}-${String(dt.m).padStart(2,'0')}-${String(dt.d).padStart(2,'0')}T${String(dt.H).padStart(2,'0')}:${String(dt.Mi).padStart(2,'0')}:${String(dt.S).padStart(2,'0')}`;}
function formatDateValue(dt){const abbr=['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];return`${abbr[dt.m-1]}${dt.d}`;}

/* ---------- Denver as-of timestamp ---------- */
function getDenverAsOf(){
  const fmt = new Intl.DateTimeFormat('en-US', {
    timeZone: 'America/Denver',
    month: 'long', day: 'numeric', year: 'numeric',
    hour: 'numeric', minute: '2-digit', hour12: true, timeZoneName: 'short'
  });
  const parts = fmt.formatToParts(new Date());
  const map = Object.fromEntries(parts.map(p=>[p.type,p.value]));
  const dp = map.dayPeriod || (+map.hour < 12 ? 'AM' : 'PM');
  return `${map.month} ${map.day}, ${map.year}, ${map.hour}:${map.minute} ${dp} ${map.timeZoneName}`;
}

/* ---------- Crypto helpers ---------- */
const DEFAULT_ITER = 150000;
const FAST_ITER = 30000; // dev only
const enc = new TextEncoder();
function bytesToB64(b){return btoa(String.fromCharCode(...new Uint8Array(b)))}
function b64ToBytes(b64){return Uint8Array.from(atob(b64), c=>c.charCodeAt(0))}
function normEmail(s){return (s||"").trim().toLowerCase()}
function randSaltB64(len=16){const a=new Uint8Array(len);crypto.getRandomValues(a);return bytesToB64(a)}

/* ---------- Worker pool for PBKDF2 ---------- */
function makeHasherWorkerURL(){
  const src = `
    const enc = new TextEncoder();
    function b64ToBytes(b64){return Uint8Array.from(atob(b64), c=>c.charCodeAt(0))}
    function bytesToB64(b){return btoa(String.fromCharCode(...new Uint8Array(b)))}
    self.onmessage = async (e)=>{
      const {recs, iterations} = e.data;
      const out = [];
      for (let i=0;i<recs.length;i++){
        const r = recs[i];
        try{
          const key = await crypto.subtle.importKey("raw", enc.encode(r.email), {name:"PBKDF2"}, false, ["deriveBits"]);
          const bits = await crypto.subtle.deriveBits({name:"PBKDF2", hash:"SHA-256", salt:b64ToBytes(r.salt), iterations}, key, 256);
          out.push({ idx: r.idx, name: r.name, salt: r.salt, hash: bytesToB64(bits), ceu: r.ceu });
        }catch(err){
          out.push({ idx: r.idx, name: r.name, salt: r.salt, hash: "ERROR", ceu: r.ceu });
        }
      }
      postMessage({out});
    };
  `;
  const blob = new Blob([src], {type:'application/javascript'});
  return URL.createObjectURL(blob);
}
async function hashWithPool(attendeesRaw, iterations){
  const poolSize = Math.min((navigator.hardwareConcurrency||4), 8);
  const url = makeHasherWorkerURL();

  // Prepare per-record salts & payload
  const payload = attendeesRaw
    .filter(r=>r.email)
    .map((r,idx)=>({ idx, name:r.name, email:r.email, ceu:r.ceu, salt: randSaltB64() }));

  // Split payload into roughly-equal chunks
  const chunks = [];
  const per = Math.ceil(payload.length / poolSize) || 1;
  for(let i=0;i<payload.length;i+=per){ chunks.push(payload.slice(i,i+per)); }

  // Launch workers
  const workers = [];
  const promises = chunks.map(chunk => new Promise((resolve)=>{
    const w = new Worker(url);
    workers.push(w);
    w.onmessage = (e)=>{ resolve(e.data.out); };
    w.postMessage({recs: chunk, iterations});
  }));

  const results = (await Promise.all(promises)).flat();

  // Cleanup blob + workers
  workers.forEach(w=>w.terminate());
  URL.revokeObjectURL(url);

  // Reorder by original idx
  results.sort((a,b)=>a.idx-b.idx);
  // Drop internal idx
  return results.map(({idx, ...rest})=>rest);
}

/* ---------- UI refs ---------- */
const $session=document.getElementById('sessionFile');
const $speaker=document.getElementById('speakerFile');
const $reg=document.getElementById('regFile');
const $tzOff=document.getElementById('tzOffset');
const $fast=document.getElementById('fastMode');
const $out=document.getElementById('out');
const $errs=document.getElementById('errs');
const $indOutSpeakers=document.getElementById('copyOutSpeakersInd');
const $indOutCEU=document.getElementById('copyOutCEUInd');
const $indErr=document.getElementById('copyErrInd');

let lastOutputSpeakers='', lastOutputCEU='', lastErrors='';

/* ---------- File util ---------- */
function readFileAsText(file){
  return new Promise((resolve,reject)=>{
    const fr=new FileReader();
    fr.onload=e=>resolve(e.target.result);
    fr.onerror=e=>reject(e);
    fr.readAsText(file);
  });
}

/* ---------- MAIN ---------- */
document.getElementById('processBtn').addEventListener('click', async ()=>{
  $out.value=''; $errs.textContent=''; lastOutputSpeakers=''; lastOutputCEU=''; lastErrors='';
  try{
    if(!$reg.files.length){
      const m='ERROR: Select Registration CSV (required).'; $errs.textContent=m; lastErrors=m; return;
    }

    // --- Parse REGISTRATION CSV ---
    const regText = await readFileAsText($reg.files[0]);
    const regRows = splitIntoLogicalRows(regText);
    if(regRows.length<2){const m='ERROR: Registration CSV has no data rows.'; $errs.textContent=m; lastErrors=m; return;}
    const regHeaders = parseCSVLine(regRows[0]).map(h=>h.trim());
    const regNorm = regHeaders.map(normalizeHeader);

    const emailIdx = regNorm.indexOf('email address');
    const firstIdx = regNorm.indexOf('first name');
    const lastIdx  = regNorm.indexOf('last name');
    const typeIdx  = regNorm.indexOf('registration type');

    if(emailIdx===-1){const m='ERROR: Registration CSV missing "Email Address" column.'; $errs.textContent=m; lastErrors=m; return;}
    if(firstIdx===-1 || lastIdx===-1){const m='ERROR: Registration CSV missing "First Name" or "Last Name" column.'; $errs.textContent=m; lastErrors=m; return;}
    if(typeIdx===-1){const m='ERROR: Registration CSV missing "Registration Type" column.'; $errs.textContent=m; lastErrors=m; return;}

    const regEmails=new Set();
    const attendeesRaw = [];
    regRows.slice(1).forEach(row=>{
      const f=parseCSVLine(row);
      const email = cleanCell(f[emailIdx]);
      const first = cleanCell(f[firstIdx]);
      const last  = cleanCell(f[lastIdx]);
      const regType = cleanCell(f[typeIdx]);
      const ceu = /ceu/i.test(regType) ? 'Yes' : 'No';
      if(email){ regEmails.add(email.toLowerCase()); }
      if(first || last || email){
        attendeesRaw.push({ name: `${first} ${last}`.trim(), email: normEmail(email), ceu });
      }
    });

    // PBKDF2 iterations (dev fast mode optional)
    const iterations = $fast.checked ? FAST_ITER : DEFAULT_ITER;

    // Hash attendees in PARALLEL
    const attendeesHashed = await hashWithPool(attendeesRaw, iterations);

    const asOf = getDenverAsOf();
    const ceuJs =
`const SESSIONS_AS_OF = "${asOf}";
const PBKDF2_ITERATIONS = ${iterations};
const ATTENDEE_INDEX = ${JSON.stringify(attendeesHashed, null, 2)};`;
    lastOutputCEU = ceuJs;

    // --- Parse SESSIONS/SPEAKERS (optional; only if both provided) ---
    if($session.files.length && $speaker.files.length){
      const [sessText, speakerText] = await Promise.all([readFileAsText($session.files[0]), readFileAsText($speaker.files[0])]);

      const sessRows=splitIntoLogicalRows(sessText);
      if(sessRows.length<2){throw new Error('Session CSV has no data rows.');}
      const sessHeaders=parseCSVLine(sessRows[0]).map(h=>h.trim());
      const sessNorm=sessHeaders.map(normalizeHeader);
      const firstDescIdx = sessNorm.indexOf('description');

      const sessions=sessRows.slice(1).map(row=>{
        const f=parseCSVLine(row),o={};
        sessNorm.forEach((h,i)=>{ o[h]=cleanCell(f[i]); });
        if(firstDescIdx!==-1){ o['description']=cleanCell(f[firstDescIdx]); }
        return o;
      });

      const spRows=splitIntoLogicalRows(speakerText);
      if(spRows.length<2){throw new Error('Speaker CSV has no data rows.');}
      const spHeaders=parseCSVLine(spRows[0]).map(h=>h.trim()), spNorm=spHeaders.map(normalizeHeader);

      const speakersMap={};
      spRows.slice(1).forEach(r=>{
        const f=parseCSVLine(r),o={}; spNorm.forEach((h,i)=>{ o[h]=cleanCell(f[i]); });
        const sess=o['session code'],code=o['code'];
        const name=`${o['first name']||''} ${o['last name']||''}`.trim().replace(/"/g,"'");
        const email=(o['email address']||'').replace(/"/g,"'");
        if(sess&&code){ (speakersMap[sess]||(speakersMap[sess]={}))[code]={name,email}; }
      });

      const tz=$tzOff.value;
      const errors=[];
      const outObjs=sessions.map((row,idx)=>{
        const rnum=idx+2;
        const s=parseDateTimeString(row['session start date/time']||'');
        const e=parseDateTimeString(row['end date/time']||'');

        const rawVF=row['2025 cta session features']||'';
        const v=rawVF.toLowerCase();
        let videoFormat='';
        if(v.includes('zoom')) videoFormat='Zoom';
        if(v.includes('embedded')) videoFormat='Embedded';
        if(v.includes('pre-recorded')||v.includes('pre recorded')||v.includes('prerecorded')) videoFormat='Embedded Simulive';
        if(v.includes('livestream')||v.includes('live stream')||v.includes('live-stream')) videoFormat='Livestream via Zoom';
        if(!videoFormat) videoFormat = rawVF;

        const speakerCodes=(row['speaker code']||'').split(',').map(x=>x.trim()).filter(Boolean);
        const speakers=[];
        speakerCodes.forEach(code=>{
          const sessCode=row['session code'];
          if(!speakersMap[sessCode]){
            errors.push(`ERROR: Session row ${rnum}: No speakers for Session Code "${sessCode}".`); return;
          }
          const info=speakersMap[sessCode][code];
          if(!info){
            const avail=Object.keys(speakersMap[sessCode]||{}).join(', ');
            errors.push(`ERROR: Session row ${rnum}: Speaker Code "${code}" not found for Session "${sessCode}". Available: [${avail}]`); return;
          }
          const email = info.email || '';
          const reg = email ? (regEmails.has(email.toLowerCase()) ? 'Yes' : 'No') : 'No';
          speakers.push({name:info.name,email,registration: reg});
        });

        const title=(row['session name']||'').replace(/"/g,"'");
        const description=(row['description']||'').replace(/"/g,"'");

        return{
          id: row['session id']||'',
          title,
          description,
          date: s?formatDate(s):'',
          time: s?formatTimeRange(s,e):'',
          datetime: s?(formatISO(s)+(tz||'')):'',
          dateValue: s?formatDateValue(s):'',
          type: row['presentation type']||'',
          theme: row['category']||'',
          specialTag: row['2025 cta special tag']||'',
          recordingStatus: row['2025 cta recording']||'',
          ceuEligibility: row['2025 cta ceu eligibility']||'',
          videoFormat,
          speakers
        };
      });

      const asOf = getDenverAsOf();
      const speakersJs = `const SESSIONS_AS_OF = "${asOf}";\n\nconst sessions = ${JSON.stringify(outObjs,null,2)};`;
      lastOutputSpeakers = speakersJs;
      $errs.textContent = errors.join('\n');
      $out.value = speakersJs; // default preview
    } else {
      // Only CEU output available
      $out.value = lastOutputCEU;
      const warn = 'Note: Sessions/Speakers not loaded. Only CEU output was generated.';
      $errs.textContent = warn; lastErrors = warn;
    }
  }catch(err){
    const m = 'ERROR: '+(err?.message||String(err)); $errs.textContent=m; lastErrors=m;
  }
});

/* ---------- copy helpers ---------- */
function copyText(t,el){
  if(!t){ $errs.textContent='Nothing to copy. Click Process first.'; return; }
  (navigator.clipboard?.writeText(t)||Promise.resolve()).then(()=>{
    el.classList.add('show');setTimeout(()=>el.classList.remove('show'),800);
  });
}
document.getElementById('copyOutSpeakersBtn').addEventListener('click',()=>copyText(lastOutputSpeakers,$indOutSpeakers));
document.getElementById('copyOutCEUBtn').addEventListener('click',()=>copyText(lastOutputCEU,$indOutCEU));
document.getElementById('copyErrBtn').addEventListener('click',()=>copyText(lastErrors,$indErr));
// Copy Speakers output without emails
document.getElementById('copyOutSpeakersNoEmailBtn').addEventListener('click', () => {
  if (!lastOutputSpeakers) { 
    $errs.textContent = 'Nothing to copy. Click Process first.'; 
    return; 
  }
  try {
    // Extract the sessions array from lastOutputSpeakers
    const match = lastOutputSpeakers.match(/const sessions = (.*);$/s);
    if (!match) throw new Error("Sessions not found in output");
    const sessions = JSON.parse(match[1]);

    // Strip out emails from speaker objects
    const sessionsNoEmail = sessions.map(s => ({
      ...s,
      speakers: (s.speakers || []).map(sp => {
        const { email, ...rest } = sp;
        return rest;
      })
    }));

    // Keep the original SESSIONS_AS_OF line
    const asOfLine = lastOutputSpeakers.split("\n")[0];
    const outStr = `${asOfLine}\n\nconst sessions = ${JSON.stringify(sessionsNoEmail, null, 2)};`;

    copyText(outStr, document.getElementById('copyOutSpeakersNoEmailInd'));
  } catch (err) {
    $errs.textContent = 'ERROR creating no-email output: ' + err.message;
  }
});
// ---------- publish CEU ----------
document.getElementById('publishCEUBtn').addEventListener('click', async () => {
  if (!lastOutputCEU) { $errs.textContent = 'Generate first'; return; }
  try {
    const res = await fetch('/api/update-gist', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(lastOutputCEU)
    });
    if (res.ok) {
      document.getElementById('publishCEUInd').classList.add('show');
      setTimeout(() => document.getElementById('publishCEUInd').classList.remove('show'), 1000);
    } else {
      $errs.textContent = 'Publish failed';
    }
  } catch (err) {
    $errs.textContent = 'Publish error: ' + err.message;
  }
});

// ---------- publish Speakers (no emails) ----------
document.getElementById('publishSpeakersNoEmailBtn').addEventListener('click', async () => {
  if (!lastOutputSpeakers) { $errs.textContent = 'Generate first'; return; }
  try {
    const match = lastOutputSpeakers.match(/const sessions = (.*);$/s);
    if (!match) throw new Error("Sessions not found in output");
    const sessions = JSON.parse(match[1]);
    const sessionsNoEmail = sessions.map(s => ({
      ...s,
      speakers: (s.speakers || []).map(sp => {
        const { email, ...rest } = sp;
        return rest;
      })
    }));
    const payload = { SESSIONS_AS_OF: getDenverAsOf(), sessions: sessionsNoEmail };

    const res = await fetch('/api/update-session-speaker-gist', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (res.ok) {
      document.getElementById('publishSpeakersNoEmailInd').classList.add('show');
      setTimeout(() => document.getElementById('publishSpeakersNoEmailInd').classList.remove('show'), 1000);
    } else {
      $errs.textContent = 'Publish failed';
    }
  } catch (err) {
    $errs.textContent = 'Publish error: ' + err.message;
  }
});

</script>
</body>
</html>
